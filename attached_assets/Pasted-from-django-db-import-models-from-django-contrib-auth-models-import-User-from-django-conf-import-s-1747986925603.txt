from django.db import models
from django.contrib.auth.models import User
from django.conf import settings
from decimal import Decimal
from django.db.models.signals import post_save
from django.dispatch import receiver
from django.utils.timezone import now
from django.utils import timezone
import logging
from django.db.models import F
import json

logger = logging.getLogger(__name__)

def save(self, *args, **kwargs):
    logger.debug(f"Members type: {type(self.members)}")
    super().save(*args, **kwargs)

def update_matching_income(member_plan):
    """
    Update matching pairs, rank, and matching income for each head member up to the 'admin' user.
    Uses the last plan price of the head member to calculate income, considering only active members.
    """
    try:
        member = member_plan.member
        parent_member = member.head_member.mlm_profile if member.head_member else None

        if not parent_member:
            return

        while parent_member.user.username != "admin":
            all_left_team_count = parent_member.count_team_members('left')['active']
            all_right_team_count = parent_member.count_team_members('right')['active']

            current_matching_pairs = min(all_left_team_count, all_right_team_count)
            new_matching_pairs = current_matching_pairs - parent_member.all_matching_pairs
            # print(parent_member.plans.last().plan.price)

            if new_matching_pairs > 0:
                last_plan = parent_member.plans.last()
                if not last_plan:
                    break

                matching_income = Decimal(last_plan.plan.matching)

                parent_member.matching_income += matching_income
                parent_member.total_income += matching_income
                parent_member.today_income += matching_income
                parent_member.account_balance += matching_income
                parent_member.all_matching_pairs += new_matching_pairs
                parent_member.matching_pairs += new_matching_pairs

                IncomeHistory.objects.create(member=parent_member, income_type='matching_income', amount=matching_income)

                next_rank = RankAndRewards.objects.filter(
                    pairs__lte=parent_member.matching_pairs, rank_no__gt=parent_member.rank_no
                ).order_by('rank_no').first()

                if next_rank:
                    parent_member.rank_no = next_rank.rank_no
                    parent_member.matching_pairs = 0 

                parent_member.save(update_fields=[
                    'matching_income', 'total_income', 'today_income', 'account_balance',
                    'all_matching_pairs', 'matching_pairs', 'rank_no'
                ])

                # Deduct income from company wallet
                try:
                    company_wallet, _ = CompanyWallet.objects.get_or_create(id=1)
                    company_wallet.deduct_from_wallet(matching_income)
                except Exception as e:
                    logger.exception(f"Error deducting matching income from company wallet: {e}")

            # Move to the next head member
            parent_member = parent_member.head_member.mlm_profile if parent_member.head_member else None
            if not parent_member:
                break

    except Exception as e:
        logger.exception(f"Error updating matching income for member {member.user.username}: {e}")

class CompanyWallet(models.Model): 
    balance = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00'))
    charges_balance = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00'))

    def add_to_wallet(self, amount):
        """Add a specified amount to the wallet."""
        if amount < 0:
            raise ValueError("Amount to add cannot be negative.")
        self.balance += Decimal(amount)
        self.save()
        return self.balance

    def deduct_from_wallet(self, amount):
        """Deduct a specified amount from the wallet."""
        if amount < 0:
            raise ValueError("Amount to deduct cannot be negative.")
        if amount > self.balance:
            raise ValueError("Insufficient balance in the wallet.")
        self.balance -= Decimal(amount)
        self.save()
        return self.balance

    def __str__(self):
        return f"Company: {self.balance}"

    class Meta:
        verbose_name = "Company Wallet"
        verbose_name_plural = "Company Wallets"

class Plan(models.Model):
    name = models.CharField(max_length=50)
    price = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00'))
    direct = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00'))
    matching = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00'))

    def __str__(self):
        return f"{self.name} - ₹{self.price}"

class Level(models.Model):
    plan = models.ForeignKey(Plan, on_delete=models.CASCADE, related_name="levels", null=True)
    level = models.IntegerField(default=0)
    distributed_amount = models.FloatField(default=0)
    resale_percentage = models.FloatField(default=0)

    def __str__(self):
        return f"Plan: {self.plan} | Level {self.level} - ₹{self.distributed_amount} - {self.resale_percentage}%"

class RankAndRewards(models.Model):
    rank_no = models.IntegerField(default=0, verbose_name="Rank Number")
    rank_name = models.CharField(max_length=30, verbose_name="Rank Name")
    royalty = models.DecimalField(max_digits=10, decimal_places=2, default=Decimal('0.00'), verbose_name="Royalty Amount")
    pairs = models.IntegerField(default=0, verbose_name="Pairs Required")
    amount = models.IntegerField(default=0, verbose_name="Reward Amount")
    reward_name = models.CharField(max_length=100, null=True, blank=True, verbose_name="Reward Name")

    def is_eligible(self, user_pairs):
        """Check if a user is eligible for this reward."""
        return user_pairs >= self.pairs

    def __str__(self):
        return f"Rank: {self.rank_no} - {self.rank_name} "

    class Meta:
        verbose_name = "Rank and Reward"
        verbose_name_plural = "Ranks and Rewards"

class Member(models.Model):
    POSITION_CHOICES = [
        ('Left', 'Left'),
        ('Right', 'Right'),
    ]
    BLOCK_CHOICES = [
        ('True', 'True'),
        ('False', 'False'),
    ]
    STATUS_CHOICES = [
        ('Active', 'Active'),
        ('Inactive', 'Inactive'),
    ]

    user = models.OneToOneField(settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name='mlm_profile')
    profile_image = models.ImageField(upload_to='profile_images/', null=True, blank=True)
    mobile_no = models.CharField(max_length=10, unique=True)
    sponsor = models.ForeignKey(settings.AUTH_USER_MODEL, null=True, blank=True, on_delete=models.SET_NULL, related_name='sponsored_users')
    head_member = models.ForeignKey(settings.AUTH_USER_MODEL, null=True, blank=True, on_delete=models.SET_NULL, related_name='head_users')
    left = models.ForeignKey(settings.AUTH_USER_MODEL, null=True, blank=True, on_delete=models.SET_NULL, related_name='left_users')
    right = models.ForeignKey(settings.AUTH_USER_MODEL, null=True, blank=True, on_delete=models.SET_NULL, related_name='right_users')

    position = models.CharField(max_length=10, choices=POSITION_CHOICES, null=True, blank=True)
    level = models.PositiveIntegerField(default=0)

    account_balance = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00'))
    today_income  = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00') )
    total_income  = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00') )
    direct_income = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00') )
    level_income  = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00') )
    resale_income = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00') )

    
    rank_no = models.PositiveIntegerField(default=0)
    matching_pairs = models.PositiveIntegerField(default=0)

    all_matching_pairs = models.PositiveIntegerField(default=0)
    matching_income  = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00'), help_text="Income from matching bonus.")

    wallet_balance = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00'), help_text="Wallet balance for the member.")
    total_withdrawal = models.DecimalField(max_digits=15, decimal_places=2, default=Decimal('0.00'), help_text="Total amount withdrawn.")

    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default="Inactive")
    block = models.CharField(max_length=10, choices=BLOCK_CHOICES, default="False")
    last_updated = models.DateTimeField(auto_now=True)
    joined_on = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f"{self.user.username} | {self.user.first_name} | {self.status}"

    class Meta:
        verbose_name = 'MLM Profile'
        verbose_name_plural = 'MLM Profiles'
        ordering = ['-joined_on']
        indexes = [
            models.Index(fields=['user']),
            models.Index(fields=['mobile_no']),
            models.Index(fields=['position']),
            models.Index(fields=['status']),
        ]

    def save(self, *args, **kwargs):
        super().save(*args, **kwargs)
        
    def update_status(self):
        if self.status == 'Inactive':
            self.status = 'Active'
            self.save()

    def place_member(self, new_member, position):
        if position not in dict(self.POSITION_CHOICES):
            raise ValueError("Position must be 'Left' or 'Right'.")

        new_member.head_member = self.user

        if position == 'Left':
            if self.left is None:
                self.left = new_member.user
            else:
                left_member = Member.objects.get(user=self.left)
                left_member.place_member(new_member, position)
        elif position == 'Right':
            if self.right is None:
                self.right = new_member.user
            else:
                right_member = Member.objects.get(user=self.right)
                right_member.place_member(new_member, position)

        self.save()
        new_member.save()

    def count_team_members(self, direction):
        count = {
            'active': 0,
            'inactive': 0,
            'total': 0,
        }
        
        try:
            if direction == 'left' and self.left:
                left_member = Member.objects.get(user=self.left)
                
                left_counts = left_member.count_team_members('left')
                right_counts = left_member.count_team_members('right')
                
                count['active'] += (1 if left_member.status == 'Active' else 0) + left_counts['active'] + right_counts['active']
                count['inactive'] += (1 if left_member.status == 'Inactive' else 0) + left_counts['inactive'] + right_counts['inactive']
                count['total'] += 1 + left_counts['total'] + right_counts['total']

            elif direction == 'right' and self.right:
                right_member = Member.objects.get(user=self.right)

                left_counts = right_member.count_team_members('left')
                right_counts = right_member.count_team_members('right')
                
                # Update the counts for the current right subtree
                count['active'] += (1 if right_member.status == 'Active' else 0) + left_counts['active'] + right_counts['active']
                count['inactive'] += (1 if right_member.status == 'Inactive' else 0) + left_counts['inactive'] + right_counts['inactive']
                count['total'] += 1 + left_counts['total'] + right_counts['total']

        except Member.DoesNotExist:
            pass

        return count

    def update_rank(self):
        """Automatically update rank based on matching pairs and reset matching_pairs."""
        next_rank = RankAndRewards.objects.filter(pairs__lte=self.matching_pairs, rank_no__gt=self.rank_no).order_by('rank_no').first()

        if next_rank:
            self.rank_no = next_rank.rank_no
            self.matching_pairs = 0
            self.save()

class MemberBankDetails(models.Model):
    member = models.ForeignKey('Member', on_delete=models.CASCADE, related_name='bank_details')
    upi_id = models.CharField(max_length=50, null=True, blank=True)
    bank_name = models.CharField(max_length=100, null=True, blank=True)
    bank_account = models.CharField(max_length=50, null=True, blank=True)
    bank_ifsc = models.CharField(max_length=20, null=True, blank=True)
    def __str__(self):
        return f"{self.member.user.username} | {self.member.user.first_name} | {self.upi_id}"

class MemberPlan(models.Model):
    STATUS_CHOICES = [
        ('Active', 'Active'),
        ('Inactive', 'Inactive'),
    ]

    plan = models.ForeignKey('Plan', on_delete=models.CASCADE, related_name='user_plans')    
    member = models.ForeignKey('Member', on_delete=models.CASCADE, related_name='plans')
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='Inactive')
    purchased_on = models.DateTimeField(auto_now_add=True)
    

    def __str__(self):
        return f"{self.member.user.username} | {self.member.user.first_name} | {self.plan.name if self.plan else 'No Plan Assigned'} | {self.status}"

    def save(self, *args, **kwargs):
        previous_status = (
            self.__class__.objects.filter(pk=self.pk).values_list('status', flat=True).first() if self.pk else None
        )
        super().save(*args, **kwargs)

        if self.status == 'Active' and previous_status != 'Active':
            self.member.status = 'Active'
            self.member.save(update_fields=['status'])

            update_matching_income(self)

            if self.member.sponsor:
                sponsor_member_profile = getattr(self.member.sponsor, 'mlm_profile', None)

            sponsor_member_old_level = sponsor_member_profile.level

            if sponsor_member_old_level == 0:
                sponsor_member_profile.level = 2
            if sponsor_member_old_level == 2:
                sponsor_member_profile.level = 4
            if sponsor_member_old_level == 4:
                sponsor_member_profile.level = 6
            if sponsor_member_old_level == 6:
                sponsor_member_profile.level = 8
            if sponsor_member_old_level == 8:
                sponsor_member_profile.level = 10
            if sponsor_member_old_level == 10:
                sponsor_member_profile.level = 20
            
            self.member.sponsor.mlm_profile.save(update_fields=['level'])

            current_sponsor = self.member.sponsor
            plan_price = Decimal(self.plan.price)
            distribution = {level.level: Decimal(level.distributed_amount) for level in self.plan.levels.all()}
            company_share = Decimal(0)
            distributed_amount = Decimal(0)
            
            level = 1
            all_levels = Level.objects.filter(plan=self.plan).count()
            while current_sponsor and level <=  all_levels:
                try: current_sponsor = current_sponsor.mlm_profile
                except AttributeError: break

                if current_sponsor.user.username == 'admin': break
                if current_sponsor.level < level or current_sponsor.status == 'Inactive':
                    current_sponsor = current_sponsor.sponsor
                    level += 1
                    continue

                amount = distribution.get(level)
                if not amount:
                    logger.warning(f"Percentage not defined for level {level}. Skipping distribution.")
                    break

                income = amount
                try:
                    current_sponsor.today_income += income
                    current_sponsor.total_income += income
                    current_sponsor.account_balance += income
                    current_sponsor.level_income += income
                    current_sponsor.save(update_fields=['today_income', 'total_income', 'account_balance', 'level_income'])

                    IncomeHistory.objects.create(
                        member=current_sponsor,
                        income_type='level_income',
                        amount=income,
                        description=f"Level {level} income from:" + self.member.user.username + self.member.user.first_name,
                        timestamp=timezone.now()
                    )

                    distributed_amount += income
                except Exception as e:
                    logger.exception(f"Error distributing level {level} income to {current_sponsor.user.username}: {e}")

                current_sponsor = current_sponsor.sponsor # Move to the next sponsor
                level += 1
                
            company_share = plan_price - distributed_amount

            try:
                company_wallet, _ = CompanyWallet.objects.get_or_create(id=1)
                company_wallet.balance += company_share
                company_wallet.save()
            except Exception as e:
                logger.exception("Error updating company wallet balance:", e)

            sponsor_member = self.member.sponsor.mlm_profile if self.member.sponsor else None

            if not sponsor_member or sponsor_member.user.username == 'admin':
                return

            direct_income = self.plan.direct

            try:
                sponsor_member.today_income += direct_income
                sponsor_member.total_income += direct_income
                sponsor_member.account_balance += direct_income
                sponsor_member.direct_income += direct_income
                sponsor_member.save(update_fields=[ 'today_income', 'total_income', 'account_balance', 'direct_income' ])

                IncomeHistory.objects.create(
                    member=sponsor_member,
                    income_type='direct_income',
                    amount=direct_income,
                    description="Direct income from sponsored :" + self.user.username + self.user.first_name,
                )

                try:
                    company_wallet, _ = CompanyWallet.objects.get_or_create(id=1)
                    company_wallet.balance -= direct_income
                    company_wallet.save()
                except Exception as e:
                    logger.exception("Error updating company wallet balance: %s", e)

            except Exception as e:
                logger.exception(f"Error processing direct income for: {e}")

class LeftTeam(models.Model):
    user = models.OneToOneField('Member', on_delete=models.CASCADE, related_name='left_team')
    members = models.ManyToManyField('Member', related_name='left_team_members', blank=True)

    def __str__(self):
        return f"Left Team of {self.user.user.username}"

    def add_member(self, new_member):
        """Adds a new member to the left team."""
        self.members.add(new_member)
    
    def team_members(self):
        """
        Returns detailed counts and lists of active, inactive, and total members in the left team.

        Returns:
            dict: A dictionary in the specified format.
        """
        active_members = self.members.filter(status='Active')
        inactive_members = self.members.filter(status='Inactive')
        total_members = self.members.all()

        return {
            'active': {
                'members': list(active_members),  # Convert QuerySet to a list
                'count': active_members.count(),
            },
            'inactive': {
                'members': list(inactive_members),  # Convert QuerySet to a list
                'count': inactive_members.count(),
            },
            'total': {
                'members': list(total_members),  # Convert QuerySet to a list
                'count': total_members.count(),
            },
        }

class RightTeam(models.Model):
    user = models.OneToOneField('Member', on_delete=models.CASCADE, related_name='right_team')
    members = models.ManyToManyField('Member', related_name='right_team_members', blank=True)

    def __str__(self):
        return f"Right Team of {self.user.user.username}"

    def add_member(self, new_member):
        """Adds a new member to the right team."""
        self.members.add(new_member)
    
    def team_members(self):
        """
        Returns detailed counts and lists of active, inactive, and total members in the right team.

        Returns:
            dict: A dictionary in the specified format.
        """
        active_members = self.members.filter(status='Active')
        inactive_members = self.members.filter(status='Inactive')
        total_members = self.members.all()

        return {
            'active': {
                'members': list(active_members),  # Convert QuerySet to a list
                'count': active_members.count(),
            },
            'inactive': {
                'members': list(inactive_members),  # Convert QuerySet to a list
                'count': inactive_members.count(),
            },
            'total': {
                'members': list(total_members),  # Convert QuerySet to a list
                'count': total_members.count(),
            },
        }

class DirectTeam(models.Model):
    user = models.OneToOneField('Member', on_delete=models.CASCADE, related_name='direct_team')
    members = models.ManyToManyField('Member', related_name='direct_referrals', blank=True)

    def __str__(self):
        return f"Direct Team of {self.user.user.username}"

    def add_direct_member(self, new_member):
        """Adds a direct referral to the team."""
        self.members.add(new_member)

    def team_members(self):
        active_members = self.members.filter(status='Active')  # This should return a QuerySet
        inactive_members = self.members.filter(status='Inactive')  # This should also return a QuerySet
        total_members = self.members.all()

        return {
            'active': {
                'members': list(active_members),  # Convert QuerySet to a list
                'count': active_members.count(),
            },
            'inactive': {
                'members': list(inactive_members),  # Convert QuerySet to a list
                'count': inactive_members.count(),
            },
            'total': {
                'members': list(total_members),  # Convert QuerySet to a list
                'count': total_members.count(),
            },
        }

    def get_level_wise_team(self):

        def get_team_level(members, level):
            """Recursively collect team members at each level."""
            level_wise[level] = level_wise.get(level, []) + list(members)
            for member in members:
                member_direct_team = DirectTeam.objects.filter(user=member).first()
                if member_direct_team:
                    get_team_level(member_direct_team.members.all(), level + 1)

        level_wise = {}
        get_team_level(self.members.all(), 1)
        return level_wise

class Transaction(models.Model):
    TRANSACTION_TYPES = [
        ('wallet_to_friend', 'wallet_to_friend'),
        ('account_to_wallet', 'account_to_wallet'),
        ('add_to_wallet', 'add_to_wallet'),
        ('account_to_bank_account', 'account_to_bank_account'),
        ('send_to_friend', 'send_to_friend'),
        ('recieved_from_friend', 'recieved_from_friend'),
    ]

    STATUS_CHOICES = [
        ('Pending', 'Pending'),
        ('Approved', 'Approved'),
        ('Rejected', 'Rejected'),
    ]

    member = models.ForeignKey('Member', on_delete=models.CASCADE, related_name='transactions')
    transaction_type = models.CharField(max_length=50, choices=TRANSACTION_TYPES, db_index=True)
    amount = models.DecimalField(max_digits=15, decimal_places=2)
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='Pending', db_index=True)
    description = models.TextField(null=True, blank=True)
    from_source = models.CharField(max_length=255, null=True, blank=True)
    to_destination = models.CharField(max_length=255, null=True, blank=True)
    utr_no = models.CharField(max_length=50, null=True, blank=True, unique=True)
    requested_on = models.DateTimeField(auto_now_add=True)
    processed_on = models.DateTimeField(null=True, blank=True)

    class Meta:
        verbose_name = 'Transaction'
        verbose_name_plural = 'Transactions'
        ordering = ['-requested_on']
        indexes = [
            models.Index(fields=['transaction_type']),
            models.Index(fields=['status']),
            models.Index(fields=['requested_on']),
        ]

    def __str__(self):
        return f"{self.member.user.username} | {self.transaction_type} | ₹{self.amount} | {self.status}"
    
    def save(self, *args, **kwargs):
        if self.status == 'Approved' and not self.processed_on:
            if self.transaction_type == 'add_to_wallet':
                self.member.wallet_balance += self.amount
            elif self.transaction_type == 'account_to_bank_account':
                if self.member.account_balance >= self.amount:
                    self.member.account_balance -= self.amount
                    self.member.total_withdrawal += self.amount
                else:
                    raise ValueError("Insufficient balance for withdrawal.")
            self.processed_on = timezone.now()
            self.member.save(update_fields=['wallet_balance', 'account_balance', 'total_withdrawal'])
        super().save(*args, **kwargs)

    @staticmethod
    def record_transaction(member, transaction_type, amount, description="", from_source=None, to_destination=None):
        """
        Creates and logs a new transaction record.
        """
        return Transaction.objects.create(
            member=member,
            transaction_type=transaction_type,
            amount=amount,
            description=description,
            from_source=from_source,
            to_destination=to_destination,
            requested_on=timezone.now(),
        )

class IncomeHistory(models.Model):
    INCOME_TYPES = [
        ('direct_income', 'Direct Income'),
        ('level_income', 'Level Income'),
        ('resale_income', 'Resale Income'),
        ('matching_income', 'Matching Income'),
    ]
    
    member = models.ForeignKey('Member', on_delete=models.CASCADE, related_name='income_history')
    income_type = models.CharField(max_length=50, choices=INCOME_TYPES, db_index=True)
    amount = models.DecimalField(max_digits=15, decimal_places=2)
    recorded_on = models.DateTimeField(default=timezone.now)
    description = models.TextField(null=True, blank=True)

    class Meta:
        verbose_name = 'Income History'
        verbose_name_plural = 'Income Histories'
        ordering = ['-recorded_on']
        indexes = [
            models.Index(fields=['member']),
            models.Index(fields=['recorded_on']),
            models.Index(fields=['income_type']),
        ]
    
    def __str__(self):
        return f"{self.member.user.username} | {self.income_type} | ₹{self.amount} | {self.recorded_on.strftime('%Y-%m-%d')}"

class RechargeTransaction(models.Model):
    user = models.ForeignKey(User, on_delete=models.CASCADE)
    mobile_no = models.CharField(max_length=15)
    amount = models.DecimalField(max_digits=10, decimal_places=2)
    company_name = models.CharField(max_length=50)
    order_id = models.CharField(max_length=100, unique=True)
    status = models.CharField(max_length=20, default="Pending")
    response_data = models.TextField(null=True, blank=True)
    recharge_date = models.DateTimeField(auto_now_add=True)

    def set_response_data(self, data):
        """Save JSON data as string."""
        self.response_data = json.dumps(data)
    
    def get_response_data(self):
        """Retrieve JSON data as dictionary."""
        return json.loads(self.response_data) if self.response_data else {}

    def __str__(self):
        return f"{self.user.username} - {self.mobile_no} - {self.status}"

